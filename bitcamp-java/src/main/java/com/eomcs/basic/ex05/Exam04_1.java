// 비트 이동 연산자 : >>, >>>, << 
package com.eomcs.basic.ex05;

public class Exam04_1 {
    public static void main(String[] args) {
      // << 비트 이동 연산자 사용법
        int i = 1;
        // 00000000 00000000 00000000 00000001 = 1
        System.out.println(i << 1);
        // 00000000 00000000 00000000 00000010 = 2
        System.out.println(i << 2);
        // 00000000 00000000 00000000 00000100 = 4 
        System.out.println(i << 3);
        // 00000000 00000000 00000000 00001000 = 8 
        System.out.println(i << 4);
        // 00000000 00000000 00000000 00010000 = 16
        // 왼쪽으로 이동 후, 
        // 오른 쪽 빈자리 : 0으로 채운다.
        // 왼쪽 경계를 넘어간 비트 : 짜른다.

        i = 0b0000_1011; // 11
        System.out.println(i << 1); // 00010110 => 22
        System.out.println(i << 2); // 00101100 => 44 
        System.out.println(i << 3); // 01011000 => 88 
        
        i = 0b01101001;
        System.out.println(i);
        // 00000000 00000000 00000000 01101001 = 105
        System.out.println(i << 1);
        // 00000000 00000000 00000000 11010010 = 210
        System.out.println(i << 2);
        // 00000000 00000000 00000001 10100100 = 420
        System.out.println(i >> 1);
        // 00000000 00000000 00000000 00110100 = 52
        System.out.println(i >> 2);
        // 00000000 00000000 00000000 00011010 = 26
    }
}

// 왼쪽 이동
// - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
// - 값을 배수로 증가시킬 때 곱하기 연산보다 비트 이동 연산이 빠르기 떄문에
//   실무에서는 배수 연산을 수행할 때 이 비트 이동 연산을 자주 사용한다.

// 오른쪽 이동
// - 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
// - 소수점 이하는 잘리는 효과를준다.
// - 실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에
//   오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.